package by.TMS_Dudak.Lesson14.Lecture;

public class MainLol {
    public static void main(String[] args) {
        //           DATE API
        //тут какая-то инфа ..... появился java.time
        //localDate --работае с датами, то, что больше дня.  (18 декабря)
        //localTime -- работает с часами, минутами и тд   (8:30)
        //localDateTime--если надо работать и с датой и со временем  (18 декабря 8:30)


        //конструктора нет, это утилитный класс, там все методы статические и ы можем получить текущую дату
        //LocalDate today = LocalDate.now()
        //isLeapYear()--проверка на высокосный год. Булевское значение
        //мы можем менять значения
        //LocalDate newYear2001 = LocalDate.of(2001, 1, 1);
        //LocalDate newYear2003 = newYear2001.withYear(2004);



        //localTime - все тоже самое что и с дэейт, но только в рамках дня от милисекунд до часов
        //LocalTime time = LocalTime.now();
        //getLong

        //есть методы сравнения для даты, которые удобнее чем equals
        //например есть две даты now1 и now2
        //sout(now1.isBefore/isAfter(now2))
        //Offset() - сдвиг

        //как поставить свою дату?
        //LocaleDate lol =  LocalDate.of(int year,int/enum month, int day);


        //Есть готовые регулярки для ограничения работы с датой и временем

        //Period и Duration
        //Period - годы, месяцы и дни с помощью of задаются значения

        //Duration --  когда мы работаем в рамках одного дня! можно получить битвин

        //мгновение (instant)

        //DayTimeFormat -- форматирование

        //----------------------------------------------------------------------
        //                        Лямбла выражения
        //функциональный интрефейс это интрфейс в котором находится один абстр метод
        //если фул серый, то это функ интрфейс и его можно заменить на лямбда выражение
        //Допустим есть интрфейс серчабле
        //в классе каком-то без имплемента пишем
        //Searchable searchable = (Car car) -> false; - lambda
        //Printable printable = new Printable(){  -- аннимный класс где принтабле тоже интрефейс
        // Override
        // public int count(int a){
        //      return 0;
        //  }
        // }
        //ФУНКЦОНАЛЬНЫЙ ИНТРЕФЕЙС МОЖНО ПРЕДСТАВИТЬ В ВИДЕ ЛЯМБДА ВЫРАЖЕНИЙ
        //Predicate -- какой-то крутой функциональный интрефейсик такой вот весь из себя. Возращает булевское значение.

        //Supplier -- ничего не принимает, но что-то возращает (нужно создать экземплыяры объекта)

        //Consumer - принимает, но не возращает. пример (форич)
        //их можно выстраивать в цепочку,

        //Functional -- принимает одно возращает другое (дабл лонг)

        //BiConsumer


    }
}
